"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(globalThis["webpackChunk_ember_auto_import_"] = globalThis["webpackChunk_ember_auto_import_"] || []).push([["vendors-node_modules_dialog-polyfill_dist_dialog-polyfill_esm_js"],{

/***/ "../node_modules/dialog-polyfill/dist/dialog-polyfill.esm.js":
/*!*******************************************************************!*\
  !*** ../node_modules/dialog-polyfill/dist/dialog-polyfill.esm.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// nb. This is for IE10 and lower _only_.\nvar supportCustomEvent=window.CustomEvent;if(!supportCustomEvent||typeof supportCustomEvent==='object'){supportCustomEvent=function CustomEvent(event,x){x=x||{};var ev=document.createEvent('CustomEvent');ev.initCustomEvent(event,!!x.bubbles,!!x.cancelable,x.detail||null);return ev;};supportCustomEvent.prototype=window.Event.prototype;}/**\n * Dispatches the passed event to both an \"on<type>\" handler as well as via the\n * normal dispatch operation. Does not bubble.\n *\n * @param {!EventTarget} target\n * @param {!Event} event\n * @return {boolean}\n */function safeDispatchEvent(target,event){var check='on'+event.type.toLowerCase();if(typeof target[check]==='function'){target[check](event);}return target.dispatchEvent(event);}/**\n * @param {Element} el to check for stacking context\n * @return {boolean} whether this el or its parents creates a stacking context\n */function createsStackingContext(el){while(el&&el!==document.body){var s=window.getComputedStyle(el);var invalid=function(k,ok){return!(s[k]===undefined||s[k]===ok);};if(s.opacity<1||invalid('zIndex','auto')||invalid('transform','none')||invalid('mixBlendMode','normal')||invalid('filter','none')||invalid('perspective','none')||s['isolation']==='isolate'||s.position==='fixed'||s.webkitOverflowScrolling==='touch'){return true;}el=el.parentElement;}return false;}/**\n * Finds the nearest <dialog> from the passed element.\n *\n * @param {Element} el to search from\n * @return {HTMLDialogElement} dialog found\n */function findNearestDialog(el){while(el){if(el.localName==='dialog'){return/** @type {HTMLDialogElement} */el;}if(el.parentElement){el=el.parentElement;}else if(el.parentNode){el=el.parentNode.host;}else{el=null;}}return null;}/**\n * Blur the specified element, as long as it's not the HTML body element.\n * This works around an IE9/10 bug - blurring the body causes Windows to\n * blur the whole application.\n *\n * @param {Element} el to blur\n */function safeBlur(el){// Find the actual focused element when the active element is inside a shadow root\nwhile(el&&el.shadowRoot&&el.shadowRoot.activeElement){el=el.shadowRoot.activeElement;}if(el&&el.blur&&el!==document.body){el.blur();}}/**\n * @param {!NodeList} nodeList to search\n * @param {Node} node to find\n * @return {boolean} whether node is inside nodeList\n */function inNodeList(nodeList,node){for(var i=0;i<nodeList.length;++i){if(nodeList[i]===node){return true;}}return false;}/**\n * @param {HTMLFormElement} el to check\n * @return {boolean} whether this form has method=\"dialog\"\n */function isFormMethodDialog(el){if(!el||!el.hasAttribute('method')){return false;}return el.getAttribute('method').toLowerCase()==='dialog';}/**\n * @param {!DocumentFragment|!Element} hostElement\n * @return {?Element}\n */function findFocusableElementWithin(hostElement){// Note that this is 'any focusable area'. This list is probably not exhaustive, but the\n// alternative involves stepping through and trying to focus everything.\nvar opts=['button','input','keygen','select','textarea'];var query=opts.map(function(el){return el+':not([disabled])';});// TODO(samthor): tabindex values that are not numeric are not focusable.\nquery.push('[tabindex]:not([disabled]):not([tabindex=\"\"])');// tabindex != \"\", not disabled\nvar target=hostElement.querySelector(query.join(', '));if(!target&&'attachShadow'in Element.prototype){// If we haven't found a focusable target, see if the host element contains an element\n// which has a shadowRoot.\n// Recursively search for the first focusable item in shadow roots.\nvar elems=hostElement.querySelectorAll('*');for(var i=0;i<elems.length;i++){if(elems[i].tagName&&elems[i].shadowRoot){target=findFocusableElementWithin(elems[i].shadowRoot);if(target){break;}}}}return target;}/**\n * Determines if an element is attached to the DOM.\n * @param {Element} element to check\n * @return {boolean} whether the element is in DOM\n */function isConnected(element){return element.isConnected||document.body.contains(element);}/**\n * @param {!Event} event\n * @return {?Element}\n */function findFormSubmitter(event){if(event.submitter){return event.submitter;}var form=event.target;if(!(form instanceof HTMLFormElement)){return null;}var submitter=dialogPolyfill.formSubmitter;if(!submitter){var target=event.target;var root='getRootNode'in target&&target.getRootNode()||document;submitter=root.activeElement;}if(!submitter||submitter.form!==form){return null;}return submitter;}/**\n * @param {!Event} event\n */function maybeHandleSubmit(event){if(event.defaultPrevented){return;}var form=/** @type {!HTMLFormElement} */event.target;// We'd have a value if we clicked on an imagemap.\nvar value=dialogPolyfill.imagemapUseValue;var submitter=findFormSubmitter(event);if(value===null&&submitter){value=submitter.value;}// There should always be a dialog as this handler is added specifically on them, but check just\n// in case.\nvar dialog=findNearestDialog(form);if(!dialog){return;}// Prefer formmethod on the button.\nvar formmethod=submitter&&submitter.getAttribute('formmethod')||form.getAttribute('method');if(formmethod!=='dialog'){return;}event.preventDefault();if(value!=null){// nb. we explicitly check against null/undefined\ndialog.close(value);}else{dialog.close();}}/**\n * @param {!HTMLDialogElement} dialog to upgrade\n * @constructor\n */function dialogPolyfillInfo(dialog){this.dialog_=dialog;this.replacedStyleTop_=false;this.openAsModal_=false;// Set a11y role. Browsers that support dialog implicitly know this already.\nif(!dialog.hasAttribute('role')){dialog.setAttribute('role','dialog');}dialog.show=this.show.bind(this);dialog.showModal=this.showModal.bind(this);dialog.close=this.close.bind(this);dialog.addEventListener('submit',maybeHandleSubmit,false);if(!('returnValue'in dialog)){dialog.returnValue='';}if('MutationObserver'in window){var mo=new MutationObserver(this.maybeHideModal.bind(this));mo.observe(dialog,{attributes:true,attributeFilter:['open']});}else{// IE10 and below support. Note that DOMNodeRemoved etc fire _before_ removal. They also\n// seem to fire even if the element was removed as part of a parent removal. Use the removed\n// events to force downgrade (useful if removed/immediately added).\nvar removed=false;var cb=function(){removed?this.downgradeModal():this.maybeHideModal();removed=false;}.bind(this);var timeout;var delayModel=function(ev){if(ev.target!==dialog){return;}// not for a child element\nvar cand='DOMNodeRemoved';removed|=ev.type.substr(0,cand.length)===cand;window.clearTimeout(timeout);timeout=window.setTimeout(cb,0);};['DOMAttrModified','DOMNodeRemoved','DOMNodeRemovedFromDocument'].forEach(function(name){dialog.addEventListener(name,delayModel);});}// Note that the DOM is observed inside DialogManager while any dialog\n// is being displayed as a modal, to catch modal removal from the DOM.\nObject.defineProperty(dialog,'open',{set:this.setOpen.bind(this),get:dialog.hasAttribute.bind(dialog,'open')});this.backdrop_=document.createElement('div');this.backdrop_.className='backdrop';this.backdrop_.addEventListener('mouseup',this.backdropMouseEvent_.bind(this));this.backdrop_.addEventListener('mousedown',this.backdropMouseEvent_.bind(this));this.backdrop_.addEventListener('click',this.backdropMouseEvent_.bind(this));}dialogPolyfillInfo.prototype=/** @type {HTMLDialogElement.prototype} */{get dialog(){return this.dialog_;},/**\n   * Maybe remove this dialog from the modal top layer. This is called when\n   * a modal dialog may no longer be tenable, e.g., when the dialog is no\n   * longer open or is no longer part of the DOM.\n   */maybeHideModal:function(){if(this.dialog_.hasAttribute('open')&&isConnected(this.dialog_)){return;}this.downgradeModal();},/**\n   * Remove this dialog from the modal top layer, leaving it as a non-modal.\n   */downgradeModal:function(){if(!this.openAsModal_){return;}this.openAsModal_=false;this.dialog_.style.zIndex='';// This won't match the native <dialog> exactly because if the user set top on a centered\n// polyfill dialog, that top gets thrown away when the dialog is closed. Not sure it's\n// possible to polyfill this perfectly.\nif(this.replacedStyleTop_){this.dialog_.style.top='';this.replacedStyleTop_=false;}// Clear the backdrop and remove from the manager.\nthis.backdrop_.parentNode&&this.backdrop_.parentNode.removeChild(this.backdrop_);dialogPolyfill.dm.removeDialog(this);},/**\n   * @param {boolean} value whether to open or close this dialog\n   */setOpen:function(value){if(value){this.dialog_.hasAttribute('open')||this.dialog_.setAttribute('open','');}else{this.dialog_.removeAttribute('open');this.maybeHideModal();// nb. redundant with MutationObserver\n}},/**\n   * Handles mouse events ('mouseup', 'mousedown', 'click') on the fake .backdrop element, redirecting them as if\n   * they were on the dialog itself.\n   *\n   * @param {!Event} e to redirect\n   */backdropMouseEvent_:function(e){if(!this.dialog_.hasAttribute('tabindex')){// Clicking on the backdrop should move the implicit cursor, even if dialog cannot be\n// focused. Create a fake thing to focus on. If the backdrop was _before_ the dialog, this\n// would not be needed - clicks would move the implicit cursor there.\nvar fake=document.createElement('div');this.dialog_.insertBefore(fake,this.dialog_.firstChild);fake.tabIndex=-1;fake.focus();this.dialog_.removeChild(fake);}else{this.dialog_.focus();}var redirectedEvent=document.createEvent('MouseEvents');redirectedEvent.initMouseEvent(e.type,e.bubbles,e.cancelable,window,e.detail,e.screenX,e.screenY,e.clientX,e.clientY,e.ctrlKey,e.altKey,e.shiftKey,e.metaKey,e.button,e.relatedTarget);this.dialog_.dispatchEvent(redirectedEvent);e.stopPropagation();},/**\n   * Focuses on the first focusable element within the dialog. This will always blur the current\n   * focus, even if nothing within the dialog is found.\n   */focus_:function(){// Find element with `autofocus` attribute, or fall back to the first form/tabindex control.\nvar target=this.dialog_.querySelector('[autofocus]:not([disabled])');if(!target&&this.dialog_.tabIndex>=0){target=this.dialog_;}if(!target){target=findFocusableElementWithin(this.dialog_);}safeBlur(document.activeElement);target&&target.focus();},/**\n   * Sets the zIndex for the backdrop and dialog.\n   *\n   * @param {number} dialogZ\n   * @param {number} backdropZ\n   */updateZIndex:function(dialogZ,backdropZ){if(dialogZ<backdropZ){throw new Error('dialogZ should never be < backdropZ');}this.dialog_.style.zIndex=dialogZ;this.backdrop_.style.zIndex=backdropZ;},/**\n   * Shows the dialog. If the dialog is already open, this does nothing.\n   */show:function(){if(!this.dialog_.open){this.setOpen(true);this.focus_();}},/**\n   * Show this dialog modally.\n   */showModal:function(){if(this.dialog_.hasAttribute('open')){throw new Error('Failed to execute \\'showModal\\' on dialog: The element is already open, and therefore cannot be opened modally.');}if(!isConnected(this.dialog_)){throw new Error('Failed to execute \\'showModal\\' on dialog: The element is not in a Document.');}if(!dialogPolyfill.dm.pushDialog(this)){throw new Error('Failed to execute \\'showModal\\' on dialog: There are too many open modal dialogs.');}if(createsStackingContext(this.dialog_.parentElement)){console.warn('A dialog is being shown inside a stacking context. '+'This may cause it to be unusable. For more information, see this link: '+'https://github.com/GoogleChrome/dialog-polyfill/#stacking-context');}this.setOpen(true);this.openAsModal_=true;// Optionally center vertically, relative to the current viewport.\nif(dialogPolyfill.needsCentering(this.dialog_)){dialogPolyfill.reposition(this.dialog_);this.replacedStyleTop_=true;}else{this.replacedStyleTop_=false;}// Insert backdrop.\nthis.dialog_.parentNode.insertBefore(this.backdrop_,this.dialog_.nextSibling);// Focus on whatever inside the dialog.\nthis.focus_();},/**\n   * Closes this HTMLDialogElement. This is optional vs clearing the open\n   * attribute, however this fires a 'close' event.\n   *\n   * @param {string=} opt_returnValue to use as the returnValue\n   */close:function(opt_returnValue){if(!this.dialog_.hasAttribute('open')){throw new Error('Failed to execute \\'close\\' on dialog: The element does not have an \\'open\\' attribute, and therefore cannot be closed.');}this.setOpen(false);// Leave returnValue untouched in case it was set directly on the element\nif(opt_returnValue!==undefined){this.dialog_.returnValue=opt_returnValue;}// Triggering \"close\" event for any attached listeners on the <dialog>.\nvar closeEvent=new supportCustomEvent('close',{bubbles:false,cancelable:false});safeDispatchEvent(this.dialog_,closeEvent);}};var dialogPolyfill={};dialogPolyfill.reposition=function(element){var scrollTop=document.body.scrollTop||document.documentElement.scrollTop;var topValue=scrollTop+(window.innerHeight-element.offsetHeight)/2;element.style.top=Math.max(scrollTop,topValue)+'px';};dialogPolyfill.isInlinePositionSetByStylesheet=function(element){for(var i=0;i<document.styleSheets.length;++i){var styleSheet=document.styleSheets[i];var cssRules=null;// Some browsers throw on cssRules.\ntry{cssRules=styleSheet.cssRules;}catch(e){}if(!cssRules){continue;}for(var j=0;j<cssRules.length;++j){var rule=cssRules[j];var selectedNodes=null;// Ignore errors on invalid selector texts.\ntry{selectedNodes=document.querySelectorAll(rule.selectorText);}catch(e){}if(!selectedNodes||!inNodeList(selectedNodes,element)){continue;}var cssTop=rule.style.getPropertyValue('top');var cssBottom=rule.style.getPropertyValue('bottom');if(cssTop&&cssTop!=='auto'||cssBottom&&cssBottom!=='auto'){return true;}}}return false;};dialogPolyfill.needsCentering=function(dialog){var computedStyle=window.getComputedStyle(dialog);if(computedStyle.position!=='absolute'){return false;}// We must determine whether the top/bottom specified value is non-auto.  In\n// WebKit/Blink, checking computedStyle.top == 'auto' is sufficient, but\n// Firefox returns the used value. So we do this crazy thing instead: check\n// the inline style and then go through CSS rules.\nif(dialog.style.top!=='auto'&&dialog.style.top!==''||dialog.style.bottom!=='auto'&&dialog.style.bottom!==''){return false;}return!dialogPolyfill.isInlinePositionSetByStylesheet(dialog);};/**\n * @param {!Element} element to force upgrade\n */dialogPolyfill.forceRegisterDialog=function(element){if(window.HTMLDialogElement||element.showModal){console.warn('This browser already supports <dialog>, the polyfill '+'may not work correctly',element);}if(element.localName!=='dialog'){throw new Error('Failed to register dialog: The element is not a dialog.');}new dialogPolyfillInfo(/** @type {!HTMLDialogElement} */element);};/**\n * @param {!Element} element to upgrade, if necessary\n */dialogPolyfill.registerDialog=function(element){if(!element.showModal){dialogPolyfill.forceRegisterDialog(element);}};/**\n * @constructor\n */dialogPolyfill.DialogManager=function(){/** @type {!Array<!dialogPolyfillInfo>} */this.pendingDialogStack=[];var checkDOM=this.checkDOM_.bind(this);// The overlay is used to simulate how a modal dialog blocks the document.\n// The blocking dialog is positioned on top of the overlay, and the rest of\n// the dialogs on the pending dialog stack are positioned below it. In the\n// actual implementation, the modal dialog stacking is controlled by the\n// top layer, where z-index has no effect.\nthis.overlay=document.createElement('div');this.overlay.className='_dialog_overlay';this.overlay.addEventListener('click',function(e){this.forwardTab_=undefined;e.stopPropagation();checkDOM([]);// sanity-check DOM\n}.bind(this));this.handleKey_=this.handleKey_.bind(this);this.handleFocus_=this.handleFocus_.bind(this);this.zIndexLow_=100000;this.zIndexHigh_=100000+150;this.forwardTab_=undefined;if('MutationObserver'in window){this.mo_=new MutationObserver(function(records){var removed=[];records.forEach(function(rec){for(var i=0,c;c=rec.removedNodes[i];++i){if(!(c instanceof Element)){continue;}else if(c.localName==='dialog'){removed.push(c);}removed=removed.concat(c.querySelectorAll('dialog'));}});removed.length&&checkDOM(removed);});}};/**\n * Called on the first modal dialog being shown. Adds the overlay and related\n * handlers.\n */dialogPolyfill.DialogManager.prototype.blockDocument=function(){document.documentElement.addEventListener('focus',this.handleFocus_,true);document.addEventListener('keydown',this.handleKey_);this.mo_&&this.mo_.observe(document,{childList:true,subtree:true});};/**\n * Called on the first modal dialog being removed, i.e., when no more modal\n * dialogs are visible.\n */dialogPolyfill.DialogManager.prototype.unblockDocument=function(){document.documentElement.removeEventListener('focus',this.handleFocus_,true);document.removeEventListener('keydown',this.handleKey_);this.mo_&&this.mo_.disconnect();};/**\n * Updates the stacking of all known dialogs.\n */dialogPolyfill.DialogManager.prototype.updateStacking=function(){var zIndex=this.zIndexHigh_;for(var i=0,dpi;dpi=this.pendingDialogStack[i];++i){dpi.updateZIndex(--zIndex,--zIndex);if(i===0){this.overlay.style.zIndex=--zIndex;}}// Make the overlay a sibling of the dialog itself.\nvar last=this.pendingDialogStack[0];if(last){var p=last.dialog.parentNode||document.body;p.appendChild(this.overlay);}else if(this.overlay.parentNode){this.overlay.parentNode.removeChild(this.overlay);}};/**\n * @param {Element} candidate to check if contained or is the top-most modal dialog\n * @return {boolean} whether candidate is contained in top dialog\n */dialogPolyfill.DialogManager.prototype.containedByTopDialog_=function(candidate){while(candidate=findNearestDialog(candidate)){for(var i=0,dpi;dpi=this.pendingDialogStack[i];++i){if(dpi.dialog===candidate){return i===0;// only valid if top-most\n}}candidate=candidate.parentElement;}return false;};dialogPolyfill.DialogManager.prototype.handleFocus_=function(event){var target=event.composedPath?event.composedPath()[0]:event.target;if(this.containedByTopDialog_(target)){return;}if(document.activeElement===document.documentElement){return;}event.preventDefault();event.stopPropagation();safeBlur(/** @type {Element} */target);if(this.forwardTab_===undefined){return;}// move focus only from a tab key\nvar dpi=this.pendingDialogStack[0];var dialog=dpi.dialog;var position=dialog.compareDocumentPosition(target);if(position&Node.DOCUMENT_POSITION_PRECEDING){if(this.forwardTab_){// forward\ndpi.focus_();}else if(target!==document.documentElement){// backwards if we're not already focused on <html>\ndocument.documentElement.focus();}}return false;};dialogPolyfill.DialogManager.prototype.handleKey_=function(event){this.forwardTab_=undefined;if(event.keyCode===27){event.preventDefault();event.stopPropagation();var cancelEvent=new supportCustomEvent('cancel',{bubbles:false,cancelable:true});var dpi=this.pendingDialogStack[0];if(dpi&&safeDispatchEvent(dpi.dialog,cancelEvent)){dpi.dialog.close();}}else if(event.keyCode===9){this.forwardTab_=!event.shiftKey;}};/**\n * Finds and downgrades any known modal dialogs that are no longer displayed. Dialogs that are\n * removed and immediately readded don't stay modal, they become normal.\n *\n * @param {!Array<!HTMLDialogElement>} removed that have definitely been removed\n */dialogPolyfill.DialogManager.prototype.checkDOM_=function(removed){// This operates on a clone because it may cause it to change. Each change also calls\n// updateStacking, which only actually needs to happen once. But who removes many modal dialogs\n// at a time?!\nvar clone=this.pendingDialogStack.slice();clone.forEach(function(dpi){if(removed.indexOf(dpi.dialog)!==-1){dpi.downgradeModal();}else{dpi.maybeHideModal();}});};/**\n * @param {!dialogPolyfillInfo} dpi\n * @return {boolean} whether the dialog was allowed\n */dialogPolyfill.DialogManager.prototype.pushDialog=function(dpi){var allowed=(this.zIndexHigh_-this.zIndexLow_)/2-1;if(this.pendingDialogStack.length>=allowed){return false;}if(this.pendingDialogStack.unshift(dpi)===1){this.blockDocument();}this.updateStacking();return true;};/**\n * @param {!dialogPolyfillInfo} dpi\n */dialogPolyfill.DialogManager.prototype.removeDialog=function(dpi){var index=this.pendingDialogStack.indexOf(dpi);if(index===-1){return;}this.pendingDialogStack.splice(index,1);if(this.pendingDialogStack.length===0){this.unblockDocument();}this.updateStacking();};dialogPolyfill.dm=new dialogPolyfill.DialogManager();dialogPolyfill.formSubmitter=null;dialogPolyfill.imagemapUseValue=null;/**\n * Installs global handlers, such as click listers and native method overrides. These are needed\n * even if a no dialog is registered, as they deal with <form method=\"dialog\">.\n */if(window.HTMLDialogElement===undefined){/**\n   * If HTMLFormElement translates method=\"DIALOG\" into 'get', then replace the descriptor with\n   * one that returns the correct value.\n   */var testForm=document.createElement('form');testForm.setAttribute('method','dialog');if(testForm.method!=='dialog'){var methodDescriptor=Object.getOwnPropertyDescriptor(HTMLFormElement.prototype,'method');if(methodDescriptor){// nb. Some older iOS and older PhantomJS fail to return the descriptor. Don't do anything\n// and don't bother to update the element.\nvar realGet=methodDescriptor.get;methodDescriptor.get=function(){if(isFormMethodDialog(this)){return'dialog';}return realGet.call(this);};var realSet=methodDescriptor.set;/** @this {HTMLElement} */methodDescriptor.set=function(v){if(typeof v==='string'&&v.toLowerCase()==='dialog'){return this.setAttribute('method',v);}return realSet.call(this,v);};Object.defineProperty(HTMLFormElement.prototype,'method',methodDescriptor);}}/**\n   * Global 'click' handler, to capture the <input type=\"submit\"> or <button> element which has\n   * submitted a <form method=\"dialog\">. Needed as Safari and others don't report this inside\n   * document.activeElement.\n   */document.addEventListener('click',function(ev){dialogPolyfill.formSubmitter=null;dialogPolyfill.imagemapUseValue=null;if(ev.defaultPrevented){return;}// e.g. a submit which prevents default submission\nvar target=/** @type {Element} */ev.target;if('composedPath'in ev){var path=ev.composedPath();target=path.shift()||target;}if(!target||!isFormMethodDialog(target.form)){return;}var valid=target.type==='submit'&&['button','input'].indexOf(target.localName)>-1;if(!valid){if(!(target.localName==='input'&&target.type==='image')){return;}// this is a <input type=\"image\">, which can submit forms\ndialogPolyfill.imagemapUseValue=ev.offsetX+','+ev.offsetY;}var dialog=findNearestDialog(target);if(!dialog){return;}dialogPolyfill.formSubmitter=target;},false);/**\n   * Global 'submit' handler. This handles submits of `method=\"dialog\"` which are invalid, i.e.,\n   * outside a dialog. They get prevented.\n   */document.addEventListener('submit',function(ev){var form=ev.target;var dialog=findNearestDialog(form);if(dialog){return;// ignore, handle there\n}var submitter=findFormSubmitter(ev);var formmethod=submitter&&submitter.getAttribute('formmethod')||form.getAttribute('method');if(formmethod==='dialog'){ev.preventDefault();}});/**\n   * Replace the native HTMLFormElement.submit() method, as it won't fire the\n   * submit event and give us a chance to respond.\n   */var nativeFormSubmit=HTMLFormElement.prototype.submit;var replacementFormSubmit=function(){if(!isFormMethodDialog(this)){return nativeFormSubmit.call(this);}var dialog=findNearestDialog(this);dialog&&dialog.close();};HTMLFormElement.prototype.submit=replacementFormSubmit;}/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dialogPolyfill);\n\n//# sourceURL=webpack://__ember_auto_import__/../node_modules/dialog-polyfill/dist/dialog-polyfill.esm.js?");

/***/ })

}]);