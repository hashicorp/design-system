/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */

import { module, test } from 'qunit';
import { setupRenderingTest } from 'showcase/tests/helpers';
import { render, find } from '@ember/test-helpers';
import { wait } from 'showcase/tests/helpers';
import hdsAnchoredPosition, {
  getFloatingUIOptions,
} from '@hashicorp/design-system-components/modifiers/hds-anchored-position';
import hdsAnchoredPositionModifier from '@hashicorp/design-system-components/modifiers/hds-anchored-position';
import { TrackedObject } from 'tracked-built-ins';
import { modifier } from 'ember-modifier';
import type { MiddlewareState, MiddlewareReturn } from '@floating-ui/dom';

// see: https://codepen.io/didoo/pen/VwNpOJb
const STYLE_CONTENT = `
body {
  margin: 0px;
  padding: 0px;
}

#ember-testing {
  margin: 0px;
  padding: 10px;
}

#wrapper {
  position: relative;
}

#anchor {
  width: 100px;
  height: 40px;
  background: green;
  display: flex;
  align-items: center;
  justify-content: center;
}

#floating {
  width: 200px;
  height: 100px;
  background: lightblue;
  display: flex;
  align-items: center;
  justify-content: center;
}

#arrow {
  position: absolute;
  width: 10px;
  height: 10px;
  background: red;
}`;

const handleStyles = () => {
  const styleElement = document.createElement('style');
  styleElement.textContent = STYLE_CONTENT;
  document.head.appendChild(styleElement);
  return styleElement;
};

module(
  'Unit | Modifier | hds-anchored-position - getFloatingUIOptions()',
  function () {
    test('returns the default values if no options are provided', function (assert) {
      const floatingUIOptions = getFloatingUIOptions({});
      assert.deepEqual(floatingUIOptions.placement, 'bottom');
      assert.deepEqual(floatingUIOptions.strategy, 'absolute');
      // this is the default generated by Floating UI for the offset
      assert.deepEqual(floatingUIOptions.middleware[0]?.name, 'offset');
      assert.deepEqual(floatingUIOptions.middleware[0]?.options, 0);
    });
    test('returns the offset options provided via `offsetOptions` to the middleware', function (assert) {
      // https://floating-ui.com/docs/offset
      let floatingUIOptions;
      floatingUIOptions = getFloatingUIOptions({ offsetOptions: 1234 });
      assert.deepEqual(floatingUIOptions.middleware[0]?.name, 'offset');
      assert.deepEqual(floatingUIOptions.middleware[0]?.options, 1234);
      floatingUIOptions = getFloatingUIOptions({
        offsetOptions: { mainAxis: 1234, crossAxis: 9876 },
      });
      assert.deepEqual(floatingUIOptions.middleware[0]?.name, 'offset');
      assert.deepEqual(floatingUIOptions.middleware[0]?.options, {
        mainAxis: 1234,
        crossAxis: 9876,
      });
    });
    test('returns the offset options for the `flip/shift` middleware functions if the `enableCollisionDetection` is set to `true`', function (assert) {
      let floatingUIOptions;
      floatingUIOptions = getFloatingUIOptions({
        enableCollisionDetection: true,
      });
      assert.deepEqual(floatingUIOptions.middleware.length, 3);
      assert.deepEqual(floatingUIOptions.middleware[0]?.name, 'offset');
      assert.deepEqual(floatingUIOptions.middleware[1]?.name, 'flip');
      assert.deepEqual(floatingUIOptions.middleware[1]?.options, {
        padding: 8,
      });
      assert.deepEqual(floatingUIOptions.middleware[2]?.name, 'shift');
      // the object contains also the `limiter` function, so we test only the padding
      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
      assert.deepEqual(floatingUIOptions.middleware[2]?.options.padding, 8);
      floatingUIOptions = getFloatingUIOptions({
        enableCollisionDetection: true,
        flipOptions: { padding: 1234 },
        shiftOptions: { padding: 9876 },
      });
      assert.deepEqual(floatingUIOptions.middleware[1]?.options, {
        padding: 1234,
      });
      assert.deepEqual(floatingUIOptions.middleware[2]?.options, {
        padding: 9876,
      });
    });
    test('returns the offset options for the `flip` middleware functions if the `enableCollisionDetection` is set to `flip`', function (assert) {
      let floatingUIOptions;
      floatingUIOptions = getFloatingUIOptions({
        enableCollisionDetection: 'flip',
      });
      assert.deepEqual(floatingUIOptions.middleware.length, 2);
      assert.deepEqual(floatingUIOptions.middleware[0]?.name, 'offset');
      assert.deepEqual(floatingUIOptions.middleware[1]?.name, 'flip');
      assert.deepEqual(floatingUIOptions.middleware[1]?.options, {
        padding: 8,
      });
      floatingUIOptions = getFloatingUIOptions({
        enableCollisionDetection: 'flip',
        flipOptions: { padding: 1234 },
      });
      assert.deepEqual(floatingUIOptions.middleware[1]?.options, {
        padding: 1234,
      });
    });
    test('returns the offset options for the `shift` middleware functions if the `enableCollisionDetection` is set to `shift`', function (assert) {
      let floatingUIOptions;
      floatingUIOptions = getFloatingUIOptions({
        enableCollisionDetection: 'shift',
      });
      assert.deepEqual(floatingUIOptions.middleware.length, 2);
      assert.deepEqual(floatingUIOptions.middleware[0]?.name, 'offset');
      assert.deepEqual(floatingUIOptions.middleware[1]?.name, 'shift');
      // the object contains also the `limiter` function, so we test only the padding
      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
      assert.deepEqual(floatingUIOptions.middleware[1]?.options.padding, 8);
      floatingUIOptions = getFloatingUIOptions({
        enableCollisionDetection: 'shift',
        shiftOptions: { padding: 9876 },
      });
      assert.deepEqual(floatingUIOptions.middleware[1]?.options, {
        padding: 9876,
      });
    });
    test('returns the offset options for the `autoPlacement` middleware functions if the `enableCollisionDetection` is set to `auto`', function (assert) {
      let floatingUIOptions;
      floatingUIOptions = getFloatingUIOptions({
        enableCollisionDetection: 'auto',
      });
      assert.deepEqual(floatingUIOptions.middleware.length, 2);
      assert.deepEqual(floatingUIOptions.middleware[0]?.name, 'offset');
      assert.deepEqual(floatingUIOptions.middleware[1]?.name, 'autoPlacement');
      assert.deepEqual(floatingUIOptions.middleware[1]?.options, {
        padding: 8,
      });
      floatingUIOptions = getFloatingUIOptions({
        enableCollisionDetection: 'auto',
        autoPlacementOptions: { padding: 9876 },
      });
      assert.deepEqual(floatingUIOptions.middleware[1]?.options, {
        padding: 9876,
      });
    });
    test('returns the `middlewareExtra` provided as an option', function (assert) {
      const testFunction = () => {
        return {
          name: 'test',
          options: { abc: 1234 },
          fn: (_state: MiddlewareState) => {
            console.log('test middleware', _state);
            return {} as MiddlewareReturn;
          },
        };
      };

      const floatingUIOptions = getFloatingUIOptions({
        enableCollisionDetection: true,
        middlewareExtra: [testFunction()],
      });
      assert.deepEqual(floatingUIOptions.middleware.length, 4);
      // we want also to test the order of the middleware (the extra should be the last)
      assert.deepEqual(floatingUIOptions.middleware[0]?.name, 'offset');
      assert.deepEqual(floatingUIOptions.middleware[1]?.name, 'flip');
      assert.deepEqual(floatingUIOptions.middleware[2]?.name, 'shift');
      assert.deepEqual(floatingUIOptions.middleware[3]?.name, 'test');
      assert.deepEqual(floatingUIOptions.middleware[3]?.options, { abc: 1234 });
    });
    test('returns the `arrow` element provided as an option ', function (assert) {
      const floatingUIOptions = getFloatingUIOptions({
        // @ts-expect-error - this in reality should be a DOM element, but we found a string works as well for this type of test
        arrowElement: 'test1234',
        arrowPadding: 1234,
      });
      assert.deepEqual(floatingUIOptions.middleware[1]?.name, 'arrow');
      assert.deepEqual(floatingUIOptions.middleware[1]?.options, {
        element: 'test1234',
        padding: 1234,
      });
    });
  },
);

// ================================================================

module('Integration | Modifier | hds-anchored-position', function (hooks) {
  setupRenderingTest(hooks);

  test('render "anchor/floating/arrow" elements with default `options`', async function (assert) {
    const styleElement = handleStyles();

    await render(
      <template>
        <div id="wrapper">
          <div id="anchor">anchor</div>
          <div id="floating"><div id="arrow"></div>floating</div>
        </div>
      </template>,
    );

    // await pauseTest();

    const anchorElement = find('#anchor');
    const floatingElement = find('#floating');
    const arrowElement = find('#arrow');
    const floatingOptions = { arrowElement: arrowElement };
    // apply the modifier to the testing elements (after the rendering)
    // @ts-expect-error: known issue with type of invocation
    await hdsAnchoredPositionModifier(
      floatingElement, // element the modifier is attached to
      [anchorElement], // positional arguments
      floatingOptions, // named arguments
    );
    // we need to wait for the Floating UI computation to complete (it's incremental)
    await wait();

    if (floatingElement && arrowElement) {
      const floatingStyle = window.getComputedStyle(floatingElement);
      const arrowStyle = window.getComputedStyle(arrowElement);
      assert.deepEqual(floatingStyle.position, 'absolute');
      assert.deepEqual(floatingStyle.top, '40px');
      assert.deepEqual(floatingStyle.left, '-50px');
      assert.deepEqual(floatingStyle.width, '200px');
      assert.deepEqual(arrowStyle.left, '95px');
      assert.deepEqual(
        arrowElement.getAttribute('data-hds-anchored-arrow-placement'),
        'bottom',
      );
    }

    styleElement.remove();
  });

  test('render "anchor/floating/arrow" elements with custom options', async function (assert) {
    const styleElement = handleStyles();

    await render(
      <template>
        <div id="wrapper">
          <div id="anchor">anchor</div>
          <div id="floating"><div id="arrow"></div>floating</div>
        </div>
      </template>,
    );
    const anchorElement = find('#anchor');
    const floatingElement = find('#floating');
    const arrowElement = find('#arrow');
    const floatingOptions = {
      placement: 'bottom-start',
      strategy: 'fixed',
      offsetOptions: 20,
      arrowElement: arrowElement,
      matchToggleWidth: true,
    };
    // apply the modifier to the elements (after the rendering)
    // @ts-expect-error: known issue with type of invocation
    await hdsAnchoredPositionModifier(
      floatingElement, // element the modifier is attached to
      [anchorElement], // positional arguments
      floatingOptions, // named arguments
    );
    // we need to wait for the Floating UI computation to complete (it's incremental)
    await wait();

    if (floatingElement && arrowElement) {
      const floatingStyle = window.getComputedStyle(floatingElement);
      const arrowStyle = window.getComputedStyle(arrowElement);
      assert.deepEqual(floatingStyle.position, 'fixed');
      assert.deepEqual(floatingStyle.top, '70px');
      assert.deepEqual(floatingStyle.left, '10px');
      assert.deepEqual(floatingStyle.width, '100px');
      assert.deepEqual(arrowStyle.left, '45px');
      assert.deepEqual(
        arrowElement?.getAttribute('data-hds-anchored-arrow-placement'),
        'bottom-start',
      );
    }

    styleElement.remove();
  });

  test('the modifier works also when applied directly in the template code', async function (assert) {
    const styleElement = handleStyles();

    const context = new TrackedObject({
      // setting the default value to make sure anchor is always defined
      anchor: document.body,
    });

    // need to use a modifier to set the anchor DOM node
    const registerAnchor = modifier((element) => {
      context.anchor = element as HTMLElement;
    });

    await render(
      <template>
        <div id="wrapper">
          <div id="anchor" {{registerAnchor}}>anchor</div>
          <div
            id="floating"
            {{hdsAnchoredPosition
              context.anchor
              placement="bottom-start"
              strategy="fixed"
              offsetOptions=20
              arrowSelector="#arrow"
            }}
          ><div id="arrow"></div>floating</div>
        </div>
      </template>,
    );

    const floatingElement = find('#floating');
    const arrowElement = find('#arrow');
    // we need to wait for the Floating UI computation to complete (it's incremental)
    await wait();

    if (floatingElement && arrowElement) {
      const floatingStyle = window.getComputedStyle(floatingElement);
      const arrowStyle = window.getComputedStyle(arrowElement);
      assert.deepEqual(floatingStyle.position, 'fixed');
      assert.deepEqual(floatingStyle.top, '70px');
      assert.deepEqual(floatingStyle.left, '10px');
      assert.deepEqual(arrowStyle.left, '45px');
      assert.deepEqual(
        arrowElement.getAttribute('data-hds-anchored-arrow-placement'),
        'bottom-start',
      );
    }

    styleElement.remove();
  });
});
